10844번 : 쉬운 계단 수
===
### 문제
---
45656이란 수를 보자.

이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.

세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)

<br>

### 입력
---
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

<br>

### 출력
---
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

<br>

### 풀이
---


> N = 1 <br>
1 2 3 4 5 6 7 8 9

> N = 2 <br>
10 12 21 23 32 34 43 45 54 56 65 67 76 78 87 89 98

<br>

N = 1 에서 N = 2로 갈 때, <br>

1. 추가하는 수가 0 인 경우, <br>
N = 1에서 끝자리 수가 1이였던 수에서 0을 추가한다.

2. 추가하는 수가 9 인 경우, <br>
N = 1에서 끝자리 수가 8이였던 수에서 9를 추가한다.

3. 추가하는 수가 1 ~ 8(num) 인 경우, <br>
N = 1에서 끝자리 수가 num-1 혹은 num+1 인 수에서 num을 추가한다.

는 것을 알 수 있었다.


```c++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;


int main(){

	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N;
	long dp[101][10];

	cin >> N;

	// 0이라는 숫자는 count하지 않는다.
	dp[1][0] = 0;
	for (int i = 1; i <= 9; i++)
		dp[1][i] = 1;

	for (int i = 2; i <= N; i++) {
		// 0을 뒤에 추가하는 경우
		dp[i][0] = dp[i - 1][1];
		for (int j = 1; j <= 9; j++) {		
			if (j == 9) dp[i][j] = dp[i - 1][j - 1] % 1000000000;
			else dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % 1000000000;
		}
	}

	long ans = 0;
	for (int i = 0; i <= 9; i++)
		ans += dp[N][i];

	cout << ans % 1000000000 << "\n";

	return 0;
}
```
