5373번 : 큐빙
=============  

### 문제  
***  
루빅스 큐브는 삼차원 퍼즐이다. 보통 루빅스 큐브는 3×3×3개의 작은 정육면체로 이루어져 있다. 퍼즐을 풀려면 각 면에 있는 아홉 개의 작은 정육면체의 색이 동일해야 한다.

큐브는 각 면을 양방향으로 90도 만큼 돌릴 수 있도록 만들어져 있다. 회전이 마친 이후에는, 다른 면을 돌릴 수 있다. 이렇게 큐브의 서로 다른 면을 돌리다 보면, 색을 섞을 수 있다.

이 문제에서는 루빅스 큐브가 모두 풀린 상태에서 시작한다. 윗 면은 흰색, 아랫 면은 노란색, 앞 면은 빨간색, 뒷 면은 오렌지색, 왼쪽 면은 초록색, 오른쪽 면은 파란색이다.

루빅스 큐브를 돌린 방법이 순서대로 주어진다. 이때, 모두 돌린 다음에 가장 윗 면의 색상을 구하는 프로그램을 작성하시오.

위의 그림은 루빅스 큐브를 푼 그림이다. 왼쪽 면은 시계방향으로 조금 돌려져 있는 상태이다.
<br>

### 입력
***

첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스는 최대 100개이다. 각 테스트 케이스는 다음과 같이 구성되어져 있다.

첫째 줄에 큐브를 돌린 횟수 n이 주어진다. (1 ≤ n ≤ 1000)
둘째 줄에는 큐브를 돌린 방법이 주어진다. 각 방법은 공백으로 구분되어져 있으며, 첫 번째 문자는 돌린 면이다. U: 윗 면, D: 아랫 면, F: 앞 면, B: 뒷 면, L: 왼쪽 면, R: 오른쪽 면이다. 두 번째 문자는 돌린 방향이다. +인 경우에는 시계 방향 (그 면을 바라봤을 때가 기준), -인 경우에는 반시계 방향이다.

<br>

### 출력
***

각 테스트 케이스에 대해서 큐브를 모두 돌린 후의 윗 면의 색상을 출력한다. 첫 번째 줄에는 뒷 면과 접하는 칸의 색을 출력하고, 두 번째, 세 번째 줄은 순서대로 출력하면 된다. 흰색은 w, 노란색은 y, 빨간색은 r, 오렌지색은 o, 초록색은 g, 파란색은 b.

<br>

### 풀이
***

구현 후 수정한 부분
1. 반시계방향은 시계방향 회전을 3번한 것과 같다. 따로 구현했던 것을 합쳐서 만들었다.

큐브를 회전하면 회전시키는 면의 테두리와, 그 테두리에 붙어있는 12개의 원소들이 회전한다.  
따라서 회전 함수를 위해, 각 면의 붙어있는 12개의 원소들에 대한 인덱스 배열을 이용하는 것이 필요하다.  
헷갈리니까 전개도를 그려놓고 구현했다.  
회전시키는 함수만 실수하지 않으면 될 것 같다.  


```c++
#include<iostream>
using namespace std;

// 큐브 인덱스 표시한 전개도

/*           U
          0  1  2
          3  4  5
          6  7  8
	L    __________      R          B
18 19 20|F36 37 38 | 27 28 29 | 45 46 47
21 22 23| 39 40 41 | 30 31 32 | 48 49 50
24 25 26| 42 43 44 | 33 34 35 | 51 52 53
        -----------
          9  10 11
          12 13 14
          15 16 17
          	 D
*/

enum POSITION{U, D, L, R, F, B, SIZE};

// 기준 : 상하좌우앞뒤 (UDLRFB)
char arr[55]; // 0 ~ 53번쩨 큐브 index들의 색깔을 저장
int cube[SIZE][3][3]; // cube의 index들을 3차원배열에 저장
char color[7] = "wygbro"; // 초창기 색깔
int conv[256]; // char -> int 변환에 사용

// 면에 붙어있는 데이터
// 왼쪽 상단에서 시작하여 시계방향
int side[SIZE][12] = {
	{47, 46, 45, 29, 28, 27, 38, 37, 36, 20, 19, 18}, // U
	{42, 43, 44, 33, 34, 35, 51, 52, 53, 24, 25, 26}, // D
	{0, 3, 6, 36, 39, 42, 9, 12, 15, 53, 50, 47}, //L
	{8, 5, 2, 45, 48, 51, 17, 14, 11, 44, 41, 38}, //R
	{6, 7, 8, 27, 30, 33, 11, 10, 9, 26, 23, 20}, //F
	{2, 1, 0, 18, 21, 24, 15, 16, 17, 35, 32, 29} //B
};


void rotate(int pos, int rotationNum){

	char temp1[12];
	char temp2[3][3];

	while(rotationNum--){

		// side index에 해당하는 arr를 시계방향으로 3칸씩 이동시키기
		// 예시 : L+라면
		// 0, 3, 6 에 있는 색깔을 36, 39, 42로 옮기겠다
		for(int i = 0; i < 12; i++)
			temp1[i] = arr[side[pos][i]];				// temp1[0] = arr[0];

		for(int i = 0; i < 12; i++)
			arr[side[pos][(i + 3) % 12]] = temp1[i];	//arr[36] = temp1[0]


		// 해당 pos에 해당하는 면의 바깥 테두리를 3칸씩 이동시키기
		for(int i = 0; i < 3; i++){
			for(int j = 0; j < 3; j++)
				temp2[j][2-i] = arr[cube[pos][i][j]];
		}

		for(int i = 0; i < 3; i++){
			for(int j = 0; j < 3; j++){
				arr[cube[pos][i][j]] = temp2[i][j];
			}
		}

	}

}


int main()
{

	// initialize
	// conv 초기화
	conv['-'] = 3; conv['+'] = 1; // 반시계방향 회전 == 시계방향회전 3번
	conv['U'] = U; conv['D'] = D; conv['L'] = L; conv['R'] = R; conv['F'] = F; conv['B'] = B;

	// cube index 배열 초기화
	for(int i = 0; i < SIZE; i++){
		for(int j = 0; j < 3; j++){
			for(int k = 0; k < 3; k++)
				cube[i][j][k] = i * 9 + j * 3 + k;
		}
	}

	// input
	int n, m;
	char input[3];
	scanf("%d", &n);

	for(int test_case = 0; test_case < n; test_case++){

		// initialize
		// 큐브 색깔 배열 초기화
		for(int i = 0; i < SIZE; i++){
			for(int j = 0; j < 3; j++){
				for(int k = 0; k < 3; k++)
					arr[cube[i][j][k]] = color[i];
			}
		}

		// 회전 방법 input
		scanf("%d", &m);
		for(int method_case = 0; method_case < m; method_case++){
			scanf("%s", input);
			int pos = conv[input[0]]; int rotationNum = conv[input[1]];
			// rotate
			rotate(pos, rotationNum);
		}


		// print result
		// 위쪽면만 출력
		for(int i = 0; i < 3; i++){
			for(int j = 0; j < 3; j++)
				printf("%c", arr[cube[U][i][j]]);
			printf("\n");
		}

	}

	return 0;
}

```
