9251번 : LCS
=============

### 문제
***
LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.

예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.
<br>

### 입력
***

첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.

<br>

### 출력
***
첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.
<br>

### 풀이
***

두 문자열을 기준으로 2차원 배열 dp를 만든다.  
두 문자열을 2차원 배열 dp를 채워가며 비교한다.  
문자가 같은 경우, dp에서 왼쪽 위 대각선 값 + 1을 채우고,  
문자가 다른 경우, dp에서 max(위쪽, 왼쪽) 값을 채워넣는다.  
<br>
왼쪽 위 대각선이 의미하는 바는, 현재 같다고 판단되는 문자가 추가되기 전까지 비교했을때  
LCS 값이다. 따라서 현재 같다고 판단되는 문자가 추가되면 그 전 LCS 값에 +1을 해주는게 맞다.  
<br>
위쪽과 왼쪽 값이 의미하는 바는 상대 혹은 자신의 문자가 각각 하나씩 없는 상황인데,  
비교하는 문자가 다른 경우에는 이 둘 중 가장 긴 LCS 값을 넣어주면 된다.  

```c++
#include <iostream>
#include <algorithm>

using namespace std;

int main(){


	char arr1[1002];
	char arr2[1002];
	int dp[1002][1002] = {0,};

	// 첫번째 행과 첫번째 열은 0
	scanf("%s", arr1 + 1);
	scanf("%s", arr2 + 1);


	int i, j;
	for(i = 1; arr1[i]; i++){
		for(j = 1; arr2[j]; j++){

			// 같은 문자가 등장했다면
			// 왼쪽 대각선 값 + 1
			if(arr1[i] == arr2[j]){
				dp[i][j] = dp[i-1][j-1] + 1;
			}

			// 문자가 다르다면
			// 왼쪽이나 위쪽 중 큰 값을 넣음
			if(arr1[i] != arr2[j]){
				dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
			}

		}
	}

	printf("%d ", dp[i-1][j-1]);

    return 0;
}

```
